
### Subiecte
- Clase Abstracte vs. Clase `final`
- Reguli de Moștenire (Simplă vs. Multiplă)
- Constructorii în Clase Abstracte
- Interfețe și Constructori
- Alegerea între Clase Abstracte și Interfețe

### Rezumat
Acest ghid acoperă regulile care guvernează clasele abstracte și interfețele în Java. Se concentrează pe diferențele lor fundamentale, incluzând contradicția logică dintre `abstract` și `final`, regulile de moștenire (o singură clasă vs. interfețe multiple) și rolul (sau absența) constructorilor în funcție de prezența stării (câmpurilor de instanță).

### Concepte
- **Contradicția `abstract` vs. `final`:** O clasă `abstract` este un șablon incomplet și _trebuie_ extinsă pentru a fi utilă. O clasă `final` este o clasă completă care _nu poate_ fi extinsă. Cele două cuvinte cheie sunt contradictorii din punct de vedere logic și nu pot fi folosite împreună.
- **Moștenirea în Java:** O clasă poate `extends` (moșteni) o singură superclasă (moștenire simplă de implementare). Această regulă previne "Problema Diamantului". Cu toate acestea, o clasă poate `implements` (implementa) oricâte interfețe dorește (moștenire multiplă de tip).
- **Constructorii în Clase Abstracte:** Deși clasele abstracte nu pot fi instanțiate _direct_, ele pot avea (și adesea au) stare (câmpuri de instanță). Constructorii sunt necesari pentru a inițializa această stare moștenită și sunt apelați de constructorul subclasei prin `super()`.
- **Constructorii în Interfețe:** Interfețele nu pot avea constructori. Scopul unui constructor este de a inițializa starea (câmpurile) unui obiect, iar interfețele (prin definiție) nu au stare de instanță.
- **Alegerea Corectă:** Folosiți o **clasă abstractă** când doriți să partajați cod de bază și stare (câmpuri) între mai multe subclase strâns înrudite (o relație "is-a"). Folosiți o **interfață** când doriți să definiți un contract de comportament (o relație "can-do") pe care îl pot implementa clase neînrudite.

###  Vocabular
- **Clasă Abstractă:** Un șablon pentru alte clase; este incompletă și nu poate fi instanțiată. Trebuie extinsă.
- **Interfață:** Un contract care definește un set de metode abstracte (și, mai nou, `default` și `static`). Nu are stare de instanță.
- **`final` (Clasă):** O clasă care este considerată definitivă și nu poate fi extinsă (moștenită).
- **Moștenire Multiplă:** Abilitatea unei clase de a moșteni de la mai mulți părinți. În Java, este interzisă pentru clase, dar permisă pentru interfețe.
- **`super()`:** Un apel explicit la constructorul superclasei, folosit de obicei ca primă linie în constructorul unei subclase.
- **Stare (State):** Datele (variabilele/câmpurile de instanță) care aparțin unui obiect și definesc proprietățile sale.

### Întrebări
- De ce este combinația `public abstract final class ...` o contradicție logică?
- Cum permite Java implementarea mai multor interfețe fără a întâmpina "Problema Diamantului" pe care ar cauza-o moștenirea mai multor clase?
- Explicați de ce o clasă abstractă are nevoie de un constructor, chiar dacă nu poate fi instanțiată cu `new`.
- Care este diferența fundamentală dintre "lipsa stării" într-o interfață și "prezența stării" într-o clasă abstractă, și cum afectează acest lucru designul?
