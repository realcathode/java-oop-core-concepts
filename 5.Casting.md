# 5. Casting (Upcasting and Downcasting)


### Subiecte
- Upcasting (Conversia implicită de la Copil la Părinte)
- Downcasting (Conversia explicită de la Părinte la Copil)
- Tipuri de Erori de Casting (Compilare vs. Rulare)

### Rezumat
Acest ghid rezumă conceptele de casting în Java. Pe baza rezultatelor testului, înțelegerea este solidă. Upcasting-ul (atribuirea unui obiect Copil unei referințe Părinte) este o operațiune sigură, implicită și fundamentală pentru polimorfism. Downcasting-ul (convertirea unei referințe Părinte la o referință Copil) este o operațiune nesigură, necesită un cast explicit și poate eșua la rulare. Ghidul reiterează diferența critică dintre erorile de compilare (când incompatibilitatea este evidentă) și erorile de rulare (`ClassCastException`), care apar atunci când tipul dinamic (real) al obiectului nu corespunde cast-ului explicit.

### Concepte
- **Upcasting:** Atribuirea unei instanțe de subclasă (Copil) unei referințe de superclasă (Părinte). Ex: `Animal a = new Pisica();`.
    - Este întotdeauna **sigur** și **implicit** (nu necesită cast explicit).
    - Se bazează pe relația "is-a" (o `Pisica` _este un_ `Animal`).
    - Referința `a` (tipul static) poate accesa _doar_ membrii definiți în `Animal`, dar va executa implementările _suprascrise_ din `Pisica` (tipul dinamic).
    
- **Downcasting:** Atribuirea unei referințe de superclasă (Părinte) unei referințe de subclasă (Copil). Ex: `Pisica p = (Pisica) a;`.
    - Este **nesigur** și necesită întotdeauna un **cast explicit** `(Pisica)`.
    - Programatorul își asumă responsabilitatea că obiectul la care se referă `a` este _într-adevăr_ o `Pisica`.
- **Eroare de Compilare (Tipuri Incompatibile):** Se întâmplă când încercați un downcast fără cast explicit sau când atribuirea este logic imposibilă pentru compilator. Ex: `Pisica p = new Animal();`. Compilatorul știe că un `Animal` nu este neapărat o `Pisica`.
- **Eroare de Rulare (`ClassCastException`):** Se întâmplă când un downcast explicit _trece_ de compilator, dar eșuează la rulare. Ex: `Animal a = new Caine(); Pisica p = (Pisica) a;`. Compilatorul este "păcălit" de cast, dar JVM-ul verifică tipul dinamic (obiectul real este `Caine`) și aruncă excepția, deoarece un `Caine` nu poate fi convertit la `Pisica`.
- **Casting-ul nu modifică Obiectul:** O conversie (cast) nu schimbă niciodată obiectul real din memorie (tipul dinamic). Ea schimbă doar "eticheta" sau "perspectiva" prin care ne uităm la acel obiect (tipul static al referinței).
- 
### Vocabular
- **Upcasting:** Procesul de a trata un obiect de un tip specific (Copil) ca fiind de un tip mai general (Părinte).
- **Downcasting:** Procesul de a trata un obiect de un tip general (Părinte) ca fiind de un tip mai specific (Copil). Necesită un cast explicit.
- **Tip Static:** Tipul referinței (variabilei), cunoscut la compilare. (Ex: `Animal a`)
- **Tip Dinamic:** Tipul obiectului real din memorie, cunoscut la rulare. (Ex: `new Pisica()`)
- **`ClassCastException`:** O eroare de _rulare_ aruncată atunci când un cast explicit eșuează, deoarece tipul real al obiectului este incompatibil cu tipul la care se face conversia.

### Întrebări
- De ce upcasting-ul este considerat "sigur" și nu necesită un cast explicit?
- Care este diferența dintre o eroare de compilare `Incompatible types` și o eroare de rulare `ClassCastException`?
- Cum putem verifica în mod sigur dacă un downcast va reuși _înainte_ de a-l executa? (Indiciu: `instanceof`).
